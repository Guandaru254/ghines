import React, { Fragment } from 'react';
import PageTitle from '../../components/PageTitle/PageTitle';
import Scrollbar from '../../components/scrollbar/scrollbar';
import BlogList from '../../components/BlogList/BlogList'; 
import fetch from 'node-fetch'; // Required for fetch in getStaticProps

// NOTE: Vercel documentation strongly recommends including the protocol for external APIs.
// Setting it to 'https://' on Vercel is the most robust way to solve the ENOTFOUND issue.
const STRAPI_BASE_URL = process.env.NEXT_PUBLIC_STRAPI_API_URL; 

// -----------------------------------------------------------
// MAIN COMPONENT: Receives 'posts' (pre-fetched and cleaned)
// -----------------------------------------------------------
const BlogPageFullwidth = ({ posts, pagination }) => {
Â  Â  // Renders the fallback message if no posts are found
Â  Â  if (!posts || posts.length === 0) {
Â  Â  Â  Â  return (
Â  Â  Â  Â  Â  Â  <Fragment>
Â  Â  Â  Â  Â  Â  Â  Â  <PageTitle pageTitle={'News & Stories'} pagesub={'Home'} />
Â  Â  Â  Â  Â  Â  Â  Â  <div style={{textAlign: 'center', padding: '100px', minHeight: '400px'}}>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h2 className="text-2xl font-bold text-gray-700">No articles found.</h2>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <p className="text-gray-500 mt-2">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Please check your console for fetch errors, verify the Strapi API URL, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  and ensure content is **Published** in Strapi.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </p>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <Scrollbar />
Â  Â  Â  Â  Â  Â  </Fragment>
Â  Â  Â  Â  );
Â  Â  }

Â  Â  // Renders the BlogList component with posts
Â  Â  return (
Â  Â  Â  Â  <Fragment>
Â  Â  Â  Â  Â  Â  <PageTitle pageTitle={'News & Stories'} pagesub={'Home'} />
Â  Â  Â  Â  Â  Â  <BlogList posts={posts} pagination={pagination} />
Â  Â  Â  Â  Â  Â  <Scrollbar />
Â  Â  Â  Â  </Fragment>
Â  Â  );
};
export default BlogPageFullwidth;


// -----------------------------------------------------------
// getStaticProps: Fetches and TRANSFORMS the list of articles
// -----------------------------------------------------------
export async function getStaticProps() {
Â  Â  
Â  Â  // Add back protocol check for robustness, even if Vercel is set to //
Â  Â  if (!STRAPI_BASE_URL || (!STRAPI_BASE_URL.startsWith('http://') && !STRAPI_BASE_URL.startsWith('https://') && !STRAPI_BASE_URL.startsWith('//'))) {
Â  Â  Â  Â  console.error("FATAL ERROR: STRAPI_BASE_URL is missing or lacks a valid protocol.");
Â  Â  Â  Â  // We continue to allow build to pass with no posts if this happens
Â  Â  Â  Â  return { props: { posts: [], pagination: {} }, revalidate: 1 };
Â  Â  }

Â  Â  try {
Â  Â  Â  Â  const apiPath = `/api/news-stories?populate=Image&sort[0]=PublishedDate:desc`;
Â  Â  Â  Â  // Ensure a protocol is used for the fetch call if the variable is protocol-less
        const fetchBaseUrl = STRAPI_BASE_URL.startsWith('//') ? `https:${STRAPI_BASE_URL}` : STRAPI_BASE_URL;
Â  Â  Â  Â  const fetchUrl = `${fetchBaseUrl}${apiPath}`;
Â  Â  Â  Â  
Â  Â  Â  Â  console.log(`[STRAPI FETCH] Attempting fetch from: ${fetchUrl}`); 
Â  Â  Â  Â  // Use node-fetch for server-side fetching (necessary in older Next.js versions)
Â  Â  Â  Â  const res = await fetch(fetchUrl); 
Â  Â  Â  Â  
Â  Â  Â  Â  if (!res.ok) {
Â  Â  Â  Â  Â  Â  const errorText = await res.text();
Â  Â  Â  Â  Â  Â  console.error(`[STRAPI FETCH ERROR] Status: ${res.status} (${res.statusText}). Response body (for debug): ${errorText.substring(0, 200)}...`);
Â  Â  Â  Â  Â  Â  throw new Error(`Strapi API returned status: ${res.status}`);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  const data = await res.json();
Â  Â  Â  Â  
Â  Â  Â  Â  console.log("--- RAW STRAPI RESPONSE DATA START (DEBUG) ---");
Â  Â  Â  Â  const rawPostDataSnippet = JSON.stringify(data).substring(0, 500) + '...';
Â  Â  Â  Â  console.log(rawPostDataSnippet); 
Â  Â  Â  Â  
Â  Â  Â  Â  const rawPosts = data.data || [];
Â  Â  Â  Â  
Â  Â  Â  Â  console.log("--- ARRAY BEING MAPPED (rawPosts.length) ---", rawPosts.length);

Â  Â  Â  Â  const formattedPosts = rawPosts
Â  Â  Â  Â  Â  Â  .map(item => {
Â  Â  Â  Â  Â  Â  Â  Â  // Use 'attributes' or the item itself (for potential custom flat formats)
Â  Â  Â  Â  Â  Â  Â  Â  const attributes = item.attributes ? item.attributes : item;

Â  Â  Â  Â  Â  Â  Â  Â  if (!item || !item.id) { 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn(`[DATA WARNING] Skipping malformed Strapi item: missing ID.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  console.log(`[ITEM CHECK] ID: ${item?.id}, Title Present: ${!!attributes.Title}`);

Â  Â  Â  Â  Â  Â  Â  Â  // Image URL Construction (handles Strapi deep population structure)
Â  Â  Â  Â  Â  Â  Â  Â  const imageRelation = attributes.Image;
Â  Â  Â  Â  Â  Â  Â  Â  const imageAttributes = imageRelation?.data?.attributes;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  let imageUrl = null;
Â  Â  Â  Â  Â  Â  Â  Â  if (imageAttributes && imageAttributes.url) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const relativeOrFullUrl = imageAttributes.url;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (relativeOrFullUrl.startsWith('/')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Prepend the base URL (which includes the protocol)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  imageUrl = `${fetchBaseUrl.replace(/\/$/, '')}${relativeOrFullUrl}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  imageUrl = relativeOrFullUrl; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // ðŸ›‘ FIX 2: Use nullish coalescing (?? null) to ensure no property is 'undefined', 
Â  Â  Â  Â  Â  Â  Â  Â  // solving the 'Error serializing' issue.
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  id: item.id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Title: attributes.Title ?? null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  PublishedDate: attributes.PublishedDate ?? null, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Author: attributes.Author ?? null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Content: attributes.Content ?? null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Slug: attributes.Slug ?? null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // This is the field that was causing the serialization failure
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Description: attributes.Description ?? null, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  PhotoCredit: attributes.PhotoCredit ?? null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Image: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Pass the full, correctly constructed URL
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  url: imageUrl ?? null, 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  })
Â  Â  Â  Â  Â  Â  .filter(post => post !== null); 

Â  Â  Â  Â  const pagination = data.meta?.pagination || {};
Â  Â  Â  Â  
Â  Â  Â  Â  console.log(`[SUCCESS] Successfully processed ${formattedPosts.length} posts.`);

Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  props: {
Â  Â  Â  Â  Â  Â  Â  Â  posts: formattedPosts, 
Â  Â  Â  Â  Â  Â  Â  Â  pagination: pagination,
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  // Use Incremental Static Regeneration (ISR) to re-fetch every 60 seconds
Â  Â  Â  Â  Â  Â  revalidate: 60, 
Â  Â  Â  Â  };

Â  Â  } catch (error) {
Â  Â  Â  Â  console.error("Critical error fetching and processing news stories list:", error.message);
Â  Â  Â  Â  // Return an empty array on failure so the component displays the friendly error message
Â  Â  Â  Â  return { 
Â  Â  Â  Â  Â  Â  props: { posts: [], pagination: {} },
Â  Â  Â  Â  Â  Â  revalidate: 60,
Â  Â  Â  Â  };
Â  Â  }
}